### 技术实现原理（简明版）

- 目标：9 张 1:1 图片，尺寸 100px，间距 12px，上排 5 个、下排 4 个，拖拽时自然流动、不跳格。

### 1) 布局与定位
- 容器 `grid` 固定为两行舞台：宽 560px（5×100 + 4×12），高 212px（2×100 + 1×12）。
- 每个卡片 `cell` 使用 `position:absolute`，不参与文档流；其位置完全由 `transform: translate(x, y)` 控制。
- 函数 `indexToXY(index)` 把序号映射为坐标，保证 5+4 的几何分布。

### 2) 首次渲染
- 用 `state.order` 记录当前排序（初始为图片数组）。
- 建立 `keyToEl` 映射（图片路径 → DOM 元素）。
- `layout(order)` 遍历非拖拽项，给每个元素设置 `transform` 到对应坐标。

### 3) 拖拽过程中（自然流动的关键）
- `dragstart`：
  - 把被拖元素切换为 `position:fixed` 跟随指针，并清空其 `transform`，避免与 fixed 叠加产生偏移。
  - 隐藏浏览器自带“拖影”（用 1×1 透明图），仅保留我们自己的跟随效果。
- 指针移动 `drag/dragover`：
  - 根据指针在容器内的位置，计算“最近的槽位” `getNearestSlotIndex(x, y)`（比较到各槽中心的距离）。
  - 在临时数组 `tempOrder` 中把拖拽项插入该槽位；对其他卡片调用 `layout(tempOrder)`，它们以 CSS 过渡平滑让位。

### 4) 放开鼠标（提交排序）
- `dragend`：把 `tempOrder` 提交给 `state.order`，并让拖拽元素飞回最终槽位（恢复 transform 到该槽位坐标，清理 fixed 样式）。
- 同步每个元素的 `data-index`，便于下一次拖拽。

### 5) 动画原理
- 仅依赖 `transform` 的过渡（`transition: transform ...`），浏览器能高效合成，不卡顿。
- 没有插入占位节点、也不改变 DOM 结构顺序，避免“跳格”与回流抖动。

### 6) 为什么看起来自然
- 其他卡片只是“在原地平滑移到新位置”，而不是被硬插入/顶开。
- 被拖拽的卡片是独立的浮层（fixed），跟随指针移动，视觉上连贯。

### 7) 可调与扩展
- 改变 `SIZE`、`GAP`、行列规则即可得到不同编排；若要自适应多行，只需改 `indexToXY` 的行/列计算。
- 可增加磁吸、碰撞边界、键盘可达性等特性，原理不变。

---

### 自然流动拖拽（极简步骤）
1. 用 `transform: translate(x,y)` 定位每张卡片；不要用网格/文档流来排布。
2. `dragstart` 时，把被拖元素变为 `position:fixed` 跟随鼠标，并把它的 `transform` 清零。
3. 鼠标移动时：根据鼠标在容器内的位置，找“最近槽位”；把该元素在临时数组里面移到那个槽位。
4. 调用 `layout(临时数组)`，让其他卡片通过 `transform` 过渡到新坐标，看起来像自动让开。
5. `dragend` 时：把临时数组保存为最终顺序，并让被拖元素过渡到最终槽位，恢复常态。

